int lifetime;  
Population population;  
int lifeCounter;          
PVector target;  

void setup() {
  size(800, 200);
  smooth();

  lifetime = 200;  //生命期
  lifeCounter = 0;  
  target = new PVector(width/2, 24);    //最终目标靶子位置
  population = new Population(0.01, 50);    //变异概率0.01, 50个火箭

}

void draw() {
  background(255);

  fill(0);
  ellipse(target.x,target.y,24,24);

  if (lifeCounter < lifetime) {
    population.live();  //火箭模拟物理运动
    lifeCounter++;
  } 
  else {
    lifeCounter = 0;
    population.fitness();   //火箭适应度
    population.selection(); //火箭选择
    population.reproduction();  //火箭繁殖
  }

  fill(0);
  text("child #: " + population.getGenerations(), 10, 18);
  text("round: " + (lifetime-lifeCounter), 10, 36);
}

void mousePressed() {   //鼠标位置为靶子位置
  target.x = mouseX;
  target.y = mouseY;
}








//1.交叉功能
//2.变异功能
//3.新基因代替老基因

class DNA {

  PVector[] genes;
  float maxforce = 0.1;

  DNA() {
    genes = new PVector[lifetime];  //火箭生命期的每一帧对应一个向量对象
    
    for (int i = 0; i < genes.length; i++) {
      genes[i] = new PVector(cos(random(TWO_PI)), sin(random(TWO_PI)));
      genes[i].mult(random(0, maxforce)); //用随机方式改变向量长度,但不要超过最大推进力
    }
  }

  
//1.交叉功能
  DNA crossover(DNA partner) {  //交叉
    PVector[] child = new PVector[genes.length];    //下一代基因数量设置
    int crossover = int(random(genes.length));      //从基因中随机提取1个
    for (int i = 0; i < genes.length; i++) {        
      if (i > crossover) child[i] = genes[i];       
      else               child[i] = partner.genes[i];
    }    
    DNA newgenes = new DNA(child);
    return newgenes;
  }

//2.变异功能    
  void mutate(float m) {    //变异
    for (int i = 0; i < genes.length; i++) {
      if (random(1) < m) {
        genes[i] = new PVector(cos(random(TWO_PI)), sin(random(TWO_PI)));
        genes[i].mult(random(0, maxforce));
      }
    }
  }
  
//3.新基因代替老基因  
  DNA(PVector[] newgenes) {
    genes = newgenes;
  }
}





//1.模拟物理运动
//2.适应度
//3.选择
//4.繁殖
//5.获取最大适应度

class Population {

  float mutationRate;          // 计数器
  Rocket[] population;         // 火箭数组
  ArrayList<Rocket> matingPool;    // 火箭交配池
  int generations;             // 迭代


   Population(float m, int num) {
    mutationRate = m;
    population = new Rocket[num];
    matingPool = new ArrayList<Rocket>();
    generations = 0;

    for (int i = 0; i < population.length; i++) {
      PVector location = new PVector(width/2,height+20);
      population[i] = new Rocket(location, new DNA());
    }
  }
  
//1.模拟物理运动
  void live () {
    for (int i = 0; i < population.length; i++) {
      population[i].run();
    }
  }
  
//2.适应度
  void fitness() {  //适应度
    for (int i = 0; i < population.length; i++) {
      population[i].fitness();
    }
  }

//3.选择
  void selection() {    //选择
    matingPool.clear();
    float maxFitness = getMaxFitness();

    for (int i = 0; i < population.length; i++) {
      float fitnessNormal = map(population[i].getFitness(),0,maxFitness,0,1);
      int n = (int) (fitnessNormal * 100);  // Arbitrary multiplier
      for (int j = 0; j < n; j++) {
        matingPool.add(population[i]);
      }
    }
  }
  
//4.繁殖
  void reproduction() { //繁殖
    for (int i = 0; i < population.length; i++) {

      int m = int(random(matingPool.size()));
      int d = int(random(matingPool.size()));
      Rocket mom = matingPool.get(m);
      Rocket dad = matingPool.get(d);
      DNA momgenes = mom.getDNA();
      DNA dadgenes = dad.getDNA();
      DNA child = momgenes.crossover(dadgenes);
      child.mutate(mutationRate);
      PVector location = new PVector(width/2,height+20);
      population[i] = new Rocket(location, child);
    }
    generations++;
  }
  
//5.获取最大适应度
  float getMaxFitness() {
    float record = 0;
    for (int i = 0; i < population.length; i++) {
       if(population[i].getFitness() > record) {
         record = population[i].getFitness();
       }
    }
    return record;
  }
  
  int getGenerations() {
    return generations;
  }

}




class Rocket {

  PVector location;
  PVector velocity;
  PVector acceleration;
  float r;
  float fitness;
  DNA dna;
  int geneCounter = 0;
  boolean hitTarget = false;   
  
  Rocket(PVector l, DNA dna_) {
    acceleration = new PVector();
    velocity = new PVector();
    location = l.get();
    r = 4;
    dna = dna_;
  }
  
//1.牛顿第二定律
  void applyForce2(PVector f) {
    acceleration.add(f);
  }
  
//2.向量加速度
  void update() {
    velocity.add(acceleration);
    location.add(velocity);
    acceleration.mult(0);
  }
  
//3.适应度  
  void fitness() {
    float d = dist(location.x, location.y, target.x, target.y);
    fitness = pow(1/d, 2);
  }
  
//4.火箭外观
  void display() {
    float theta = velocity.heading2D() + PI/2;
    fill(200, 100);
    stroke(0);
    pushMatrix();
        translate(location.x, location.y);
        rotate(theta);

        rectMode(CENTER);
        fill(0);
        rect(-r/2, r*2, r/2, r);
        rect(r/2, r*2, r/2, r);

        fill(175);
        beginShape(TRIANGLES);
            vertex(0, -r*2);
            vertex(-r, r*2);
            vertex(r, r*2);
        endShape();

    popMatrix();
  }
  
//5.火箭坐标与靶子坐标距离检测  
  void checkTarget() {
    float d = dist(location.x, location.y, target.x, target.y);
    if (d < 12) {
      hitTarget = true;
    } 
  }
  
//6.火箭坐标与靶子坐标距离不在指定范围内不断地重复尝试  
  void run() {
    checkTarget(); 
    if (!hitTarget) {
      applyForce2(dna.genes[geneCounter]);
      geneCounter = (geneCounter + 1) % dna.genes.length;
      update();
    }
    display();
  }

  float getFitness() {
    return fitness;
  }

  DNA getDNA() {
    return dna;
  }

}
